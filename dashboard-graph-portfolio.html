<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Graph 0.4</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/js/all.min.js"></script>

    <script src="js/dashboard-shared.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap');

        :root {
            --bg-color: #050505;
            --neon-cyan: #00f3ff;
            --neon-blue: #0066ff;
            --glass-bg: rgba(0, 20, 40, 0.95);
            --text-color: #e0f7fa;
            --neon-red: #ff0044;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            padding-right: 0;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background-color: var(--bg-color);
            background-image:
                radial-gradient(circle at 20% 80%, rgba(0, 243, 255, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 102, 255, 0.05) 0%, transparent 50%),
                linear-gradient(rgba(0, 243, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 243, 255, 0.1) 1px, transparent 1px);
            background-size: 100% 100%, 100% 100%, 50px 50px, 50px 50px;
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            padding: 10px;
            gap: 10px;
        }

        /* HEADER (mantenuto) */
        .header-bar {
            background: var(--glass-bg);
            border: 1px solid var(--neon-cyan);
            border-radius: 8px;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            backdrop-filter: blur(10px);
            min-height: 70px;
            z-index: 10;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
        }

        .user-info-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .user-label {
            color: var(--neon-cyan);
            font-weight: bold;
        }

        .username-display {
            color: var(--text-color);
            text-transform: uppercase;
        }

        .flag-icon {
            font-size: 18px;
        }

        .header-center {
            flex: 1;
            text-align: center;
        }

        .header-center h1 {
            font-size: 1.8rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-blue));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 10px var(--neon-cyan);
            margin: 0;
        }

        .header-right {
            display: flex;
            gap: 15px;
            align-items: center;
            flex: 1;
            justify-content: flex-end;
        }

        select,
        button {
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid var(--neon-blue);
            background: rgba(0, 10, 25, 0.9);
            color: var(--neon-cyan);
            padding: 8px 15px;
            transition: all 0.3s;
        }

        select:hover,
        button:hover {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.3);
        }

        .close-button:hover {
            border-color: var(--neon-red);
            color: var(--neon-red);
            box-shadow: 0 0 15px rgba(255, 0, 68, 0.3);
        }

        /* CHART CONTAINER */
        .chart-container {
            flex: 1;
            background: var(--glass-bg);
            border: 1px solid var(--neon-cyan);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .pie-area {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Wrapper del canvas + SVG + Labels */
        /* Aumento il margine per le etichette esterne impilate */
        .chart-wrapper {
            position: relative;
            width: 75vh;
            height: 75vh;
            max-width: 750px;
            max-height: 750px;
            margin: 80px;
            box-sizing: content-box;
        }

        #pieCanvas {
            width: 100% !important;
            height: 100% !important;
            z-index: 2;
        }

        /* SVG per le linee: deve coprire esattamente il canvas */
        .connection-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: visible;
        }

        .connection-line {
            fill: none;
            stroke-width: 1.5;
            stroke-dasharray: 4, 4;
            /* Linea tratteggiata Tron */
            opacity: 0.9;
            filter: drop-shadow(0 0 2px currentColor);
            transition: stroke 0.2s;
        }

        /* LABEL ESTERNE (Legenda) */
        #labelsContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .chart-label {
            position: absolute;
            font-size: 11px;
            font-weight: bold;
            color: var(--text-color);
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
            background: rgba(0, 20, 40, 0.95);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid;
            white-space: nowrap;
            pointer-events: auto;
            transition: all 0.2s;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            cursor: default;
        }

        .chart-label:hover {
            z-index: 20;
            background: rgba(0, 20, 40, 1);
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--neon-cyan);
        }

        .total-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 5;
            pointer-events: none;
        }

        .total-label {
            font-size: 12px;
            color: var(--neon-blue);
            margin-bottom: 2px;
        }

        .total-value {
            font-size: 20px;
            font-weight: 900;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
        }

        /* LOADING (mantenuto) */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 5, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 243, 255, 0.1);
            border-top: 3px solid var(--neon-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @media (max-width: 768px) {
            .header-bar {
                flex-direction: column;
                gap: 10px;
                padding: 10px;
            }

            .header-center h1 {
                font-size: 1.4rem;
            }

            .chart-wrapper {
                width: 90vw;
                height: 90vw;
                margin: 10px;
            }

            .chart-label {
                font-size: 9px;
                padding: 2px 4px;
            }
        }
    </style>
</head>

<body>

    <div id="loading">
        <div class="spinner"></div>
        <div style="margin-top: 20px; color: var(--neon-cyan); letter-spacing: 2px;">LOADING...</div>
    </div>

    <div class="header-bar">
        <div class="header-left">
            <div class="user-info-row">
                <strong class="user-label" id="user-label-text">USER:</strong>
                <span id="username-display" class="username-display"></span>
            </div>
            <div class="user-info-row">
                <span class="flag-icon" id="languageFlag"></span>
                <span id="languageDisplay"></span>
                <span style="margin: 0 5px; color: var(--neon-blue);">|</span>
                <span id="currencyDisplay"></span>
            </div>
        </div>

        <div class="header-center">
            <h1 id="portfolio-title">Grafico Portfolio</h1>
        </div>
        <div class="header-right">
            <select id="grouping-select" onchange="renderChart()"></select>
            <button class="close-button" onclick="closeWindow()" id="close-btn">Chiudi</button>
        </div>
    </div>

    <div class="chart-container" id="chartContainer">
        <div class="pie-area">
            <div class="chart-wrapper">
                <canvas id="pieCanvas"></canvas>
                <div id="totalDisplay" class="total-display"></div>

                <svg id="connectionSvg" class="connection-svg"></svg>
                <div id="labelsContainer"></div>
            </div>
        </div>
    </div>

    <script>
        /* ================= GLOBALS ================= */
        const API_URL = "https://feweb-tunnel.fe-web.eu";
        let portfolioData = [];
        let classificationMap = {};
        let pieChart = null;
        let chartData = [];
        let totalValue = 0;
        let classificationFilter = [];
        let availableLanguages = [];
        let currencies = [];

        const urlParams = new URLSearchParams(window.location.search);
        const username = urlParams.get('username') || 'USER';
        const token = urlParams.get('token');
        const language = urlParams.get('language') || 'it_IT';
        const currency = urlParams.get('currency') || 'EUR';
        const initialGrouping = urlParams.get('grouping') || "";

        /* ================= TRANSLATION LOGIC ================= */
        async function loadTranslations(lang) {
            try {
                const response = await fetch(`lang/${lang}.json`);
                if (!response.ok) throw new Error(`Translation file not found lang/${lang}.json`);
                translations = await response.json();
            } catch (error) {
                console.error('❌ Error loading translations:', error);
                translations = {};
            }
        }

        function getTranslation(key) {
            return translations[key] || key;
        }

        function updatePageTranslations() {
            // Header
            const titleEl = document.getElementById('portfolio-title');
            if (titleEl) titleEl.textContent = getTranslation('int.portfolio');

            // Close button
            const closeBtn = document.getElementById('close-btn');
            if (closeBtn) closeBtn.textContent = getTranslation('int.close');

            // User Label
            const userLabel = document.getElementById('user-label-text');
            if (userLabel) userLabel.textContent = getTranslation('int.user.label');
        }

        /* ================= INIT ================= */
        const accountsParam = urlParams.get('accounts');
        const selectedAccounts = accountsParam ? accountsParam.split(',') : [];

        async function init() {
            document.getElementById('username-display').textContent = username;

            // Load resources first
            await Promise.all([
                initializeLanguages(),
                loadTranslations(language),
                loadCurrencies(language)
            ]);

            updateUserInfoUI();
            updatePageTranslations();


            loadPortfolio(); // Load data and populate combobox (uses getTranslation)

            document.getElementById("loading").style.display = "none";
        }

        window.onload = init;

        /* ================= LANGUAGE & CURRENCY LOGIC (Unchanged) ================= */
        async function loadLanguageManifest() {
            try {
                const response = await fetch('lang/manifest.json');
                if (!response.ok) return [];
                const manifest = await response.json();
                if (manifest.classification) classificationFilter = manifest.classification;
                return manifest.languages || [];
            } catch (e) { console.error(e); return []; }
        }

        async function initializeLanguages() {
            const codes = await loadLanguageManifest();
            for (const code of codes) {
                try {
                    const res = await fetch(`lang/${code}.json`);
                    if (res.ok) {
                        const d = await res.json();
                        availableLanguages.push({
                            code: d['int.language.code'],
                            description: d['int.language.description'],
                            flag: d['img.language.flag']
                        });
                    }
                } catch (e) { }
            }
        }

        async function loadCurrencies(lang) {
            try {
                const res = await fetch(`currency/${lang}.json`);
                if (res.ok) currencies = await res.json();
            } catch (e) { console.error(e); }
        }

        function updateUserInfoUI() {
            const l = availableLanguages.find(x => x.code === language);
            if (l) {
                document.getElementById('languageFlag').textContent = l.flag;
                document.getElementById('languageDisplay').textContent = l.description;
            } else {
                document.getElementById('languageDisplay').textContent = language;
            }

            const c = currencies.find(x => x.currency === currency);
            const symbol = c && c['img.currency.flag'] ? c['img.currency.flag'] : '';
            document.getElementById('currencyDisplay').textContent = `${symbol} ${currency}`;
        }

        /* ================= DATA LOADING (MODIFICATO: Traduzione Raggruppamento) ================= */
        async function loadPortfolio() {
            try {
                const res = await fetch(`${API_URL}/getportfolio`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ username, token, language, filter: "", code: "" })
                });
                const data = await res.json();

                if (data.status !== "ok") {
                    alert("Errore caricamento dati");
                    return;
                }

                let cList = data.classification;
                if (typeof cList === "string") {
                    try { cList = JSON.parse(cList.replace(/'/g, '"')); } catch { }
                }

                // 1. APPLICA TRADUZIONE ALLA CLASSIFICAZIONE (per il selettore)
                if (Array.isArray(cList)) {
                    cList.forEach(i => {
                        if (i.id_instrument) classificationMap[i.id_instrument] = i;

                        // Modifica Chiave 1: Usa getTranslation per tradurre la chiave del raggruppamento
                        if (i.label) {
                            i.label = getTranslation(i.label);
                        }
                    });
                }

                const select = document.getElementById('grouping-select');
                populateGroupingSelectSummary(
                    select,
                    classificationFilter.length > 0 ? classificationFilter : (Array.isArray(cList) ? cList : []),
                    getTranslation, // Passa la funzione di traduzione
                    initialGrouping,
                    // Modifica Chiave 2: Traduci l'etichetta di default
                    getTranslation("int.noselection")
                );
                // Filter if accounts are specified
                let rawData = parsePortfolioItems(data.portfolio, classificationFilter);
                if (selectedAccounts.length > 0) {
                    rawData = rawData.filter(item => selectedAccounts.includes(item.id_account));
                }
                portfolioData = rawData;
                renderChart();
            } catch (e) {
                console.error(e);
                alert("Errore caricamento dati");
            }
        }


        /* ================= CHART RENDERING ================= */
        function generateTronColors(n) {
            // Palette colori Tron
            const c = ['#00F3FF', '#0066FF', '#FF3366', '#00FFAA', '#FFAA00', '#CC00FF', '#00CCFF', '#FF6600', '#00FF66', '#FF00CC', '#0099FF', '#FF0066'];
            return Array.from({ length: n }, (_, i) => c[i % c.length]);
        }

        function renderChart() {
            const grouping = document.getElementById('grouping-select').value;
            const grouped = getGroupedData(portfolioData, classificationMap, grouping);

            // 3. ASSICURA LA TRADUZIONE DELLE LABEL DEL GRAFICO
            grouped.forEach(item => {
                if (item.label) {
                    item.label = getTranslation(item.label);
                }
            });

            chartData = grouped.length > 12 ? grouped.slice(0, 12) : grouped;

            if (chartData.length === 0) {
                document.querySelector('.pie-area').innerHTML = '<div style="color: var(--neon-cyan); text-align: center; font-size: 1.5rem; width: 100%; text-shadow: 0 0 10px var(--neon-cyan);">NESSUN DATO DISPONIBILE</div>';
                document.getElementById('totalDisplay').style.display = 'none';
                return;
            }

            // ... (resto della funzione renderChart invariato) ...

            totalValue = chartData.reduce((a, b) => a + b.value, 0);
            const colors = generateTronColors(chartData.length);

            if (pieChart) pieChart.destroy();

            document.getElementById('labelsContainer').innerHTML = '';
            document.getElementById('connectionSvg').innerHTML = '';

            if (window.ChartDataLabels) Chart.register(ChartDataLabels);

            const ctx = document.getElementById('pieCanvas').getContext('2d');
            pieChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: chartData.map(i => i.label),
                    datasets: [{
                        data: chartData.map(i => i.value),
                        backgroundColor: colors,
                        // Bordi più scuri per contrasto Tron
                        borderColor: '#050505',
                        borderWidth: 2,
                        hoverOffset: 15
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '30%',
                    layout: { padding: 0 },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => {
                                    const v = ctx.raw;
                                    const p = ((v / totalValue) * 100).toFixed(1);
                                    return `${ctx.label}: ${formatCurrency(v)} (${p}%)`;
                                }
                            },
                            backgroundColor: 'rgba(0, 20, 40, 0.95)',
                            borderColor: '#00f3ff',
                            borderWidth: 1
                        },
                        datalabels: {
                            color: '#050505',
                            formatter: (v) => ((v / totalValue) * 100).toFixed(0) + '%',
                            font: { weight: 'bold', size: 10 },
                            backgroundColor: (ctx) => ctx.dataset.backgroundColor[ctx.dataIndex] + 'E0', // 88% opacità
                            borderRadius: 3,
                            padding: 2,
                            display: (ctx) => (ctx.raw / totalValue) > 0.03,
                            align: 'center',
                            anchor: 'center'
                        }
                    },
                    animation: {
                        // Dopo l'animazione, disegna le linee e le label
                        onComplete: () => {
                            drawExternalLabelsAndLines(pieChart, colors);
                        }
                    }
                }
            });

            updateTotalDisplay();
        }

        /* ================= EXTERNAL LABELS & LINES DRAWING LOGIC (RISOLTO Sovrapposizioni) ================= */
        function drawExternalLabelsAndLines(chart, colors) {
            const container = document.getElementById('labelsContainer');
            const svg = document.getElementById('connectionSvg');
            container.innerHTML = '';
            svg.innerHTML = '';

            const meta = chart.getDatasetMeta(0);
            if (meta.data.length === 0) return;

            // Limiti verticali del canvas/wrapper
            const chartTop = 0;
            const chartBottom = chart.height;

            // Centro del canvas
            const centerX = chart.width / 2;
            const centerY = chart.height / 2;

            // Distanza del punto esterno (End della linea)
            const maxRadius = meta.data[0].outerRadius;
            const externalRadius = maxRadius * 1.35;
            const labelPositionRadius = maxRadius * 1.45;
            const labelPadding = 5; // Spazio verticale tra le etichette

            const allLabels = [];

            // PRIMO LOOP: Creazione DOM, Misurazione e Calcolo Posizione Iniziale
            meta.data.forEach((element, index) => {
                const model = element;
                const midAngle = model.startAngle + (model.endAngle - model.startAngle) / 2;

                const startX = centerX + Math.cos(midAngle) * maxRadius;
                const startY = centerY + Math.sin(midAngle) * maxRadius;

                const elbowX = centerX + Math.cos(midAngle) * externalRadius;
                const elbowY = centerY + Math.sin(midAngle) * externalRadius;

                let labelX = centerX + Math.cos(midAngle) * labelPositionRadius;
                let labelY = centerY + Math.sin(midAngle) * labelPositionRadius;

                const isRight = Math.cos(midAngle) >= 0;

                // Creazione DOM e popolamento del contenuto
                const labelDiv = document.createElement('div');
                labelDiv.className = 'chart-label';
                const value = chartData[index].value;
                const percentage = ((value / totalValue) * 100).toFixed(1);
                labelDiv.innerHTML = `
                    ${chartData[index].label}<br>
                    <small>(${formatCurrency(value)}) ${percentage}%</small>
                `;
                labelDiv.style.borderColor = colors[index];
                labelDiv.style.color = colors[index];
                container.appendChild(labelDiv);

                // Misura label
                const width = labelDiv.offsetWidth;
                const height = labelDiv.offsetHeight;

                // Regolazione orizzontale
                if (isRight) {
                    labelDiv.style.left = `${labelX}px`;
                } else {
                    labelDiv.style.left = `${labelX - width}px`;
                }

                // Centratura verticale iniziale (Y Iniziale)
                labelY -= height / 2;

                allLabels.push({
                    initialY: labelY, // Posizione Y calcolata radialmente
                    y: labelY,        // Posizione Y che verrà aggiustata
                    height: height,
                    width: width,
                    index: index,
                    isRight: isRight,
                    element: labelDiv,
                    linePoints: { startX, startY, elbowX, elbowY }
                });
            });

            // SECONDO LOOP: Implementazione Stacking Verticale e Clamping (Collision Avoidance)

            // Ordina le etichette in base alla posizione Y iniziale per l'algoritmo di stacking
            const sortedLabels = allLabels.sort((a, b) => a.initialY - b.initialY);

            // Filtra e prepara gli array per i due lati (sinistra e destra)
            const rightLabels = sortedLabels.filter(l => l.isRight);
            const leftLabels = sortedLabels.filter(l => !l.isRight);

            // Funzione di Stacking e Clamping
            function stackAndClamp(labels) {
                if (labels.length === 0) return;

                // PASSATA 1: Stacking verso il basso (se le etichette si sovrappongono, le sposta in basso)
                for (let i = 1; i < labels.length; i++) {
                    const current = labels[i];
                    const previous = labels[i - 1];
                    const minAllowedY = previous.y + previous.height + labelPadding;
                    if (current.y < minAllowedY) {
                        current.y = minAllowedY;
                    }
                }

                // CLAMPING: Vincolo Top/Bottom
                labels.forEach(l => {
                    // Vincolo Bottom (non deve andare sotto il limite inferiore)
                    if (l.y + l.height > chartBottom) {
                        l.y = chartBottom - l.height;
                    }
                    // Vincolo Top (non deve andare sopra il limite superiore)
                    if (l.y < chartTop) {
                        l.y = chartTop;
                    }
                });

                // PASSATA 2: Stacking verso l'alto (aggiusta le etichette superiori se quelle sotto sono state spinte su)
                for (let i = labels.length - 2; i >= 0; i--) {
                    const current = labels[i];
                    const next = labels[i + 1];
                    const maxAllowedY = next.y - current.height - labelPadding;
                    if (current.y > maxAllowedY) {
                        current.y = maxAllowedY;
                    }
                }

                // CLAMPING Finale Top (se le modifiche hanno spinto troppo in alto)
                labels.forEach(l => {
                    if (l.y < chartTop) {
                        l.y = chartTop;
                    }
                });
            }

            stackAndClamp(rightLabels);
            stackAndClamp(leftLabels);


            // TERZO LOOP: Applicazione Posizioni Finali e Disegno Linee SVG
            allLabels.forEach(item => {
                // Aggiorna la posizione finale nel DOM
                item.element.style.top = `${item.y}px`;

                // Punto END della linea (punta al centro del lato della label più vicino al centro)
                let endLineY = item.y + item.height / 2; // Usa la Y aggiustata

                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("class", "connection-line");
                path.style.stroke = colors[item.index];

                // Calcola il punto di attacco sul bordo della label (sinistro o destro)
                let labelAttachmentX = item.isRight ? item.element.offsetLeft : (item.element.offsetLeft + item.element.offsetWidth);

                // Linea spezzata (Start -> Elbow X/Aggiusted Y -> Label Attachment X/Aggiusted Y)
                // Usiamo la Y aggiustata anche per l'ElbowY per allineare la linea
                path.setAttribute("d", `M ${item.linePoints.startX} ${item.linePoints.startY} 
                                       L ${item.linePoints.elbowX} ${endLineY} 
                                       L ${labelAttachmentX} ${endLineY}`);

                svg.appendChild(path);
            });
        }


        /* ================= UTILS (Unchanged) ================= */
        function updateTotalDisplay() {
            const el = document.getElementById('totalDisplay');
            el.innerHTML = `<div class="total-label">TOTALE</div><div class="total-value">${formatCurrency(totalValue)}</div>`;
        }

        function formatCurrency(v) {
            return new Intl.NumberFormat(language.replace('_', '-'), {
                style: "currency", currency: currency, maximumFractionDigits: 0
            }).format(v);
        }

        function closeWindow() { window.close(); }

        // Resize handler per ridisegnare linee
        let rT;
        window.onresize = () => {
            clearTimeout(rT);
            rT = setTimeout(() => {
                if (pieChart) {
                    pieChart.resize();
                    drawExternalLabelsAndLines(pieChart, pieChart.data.datasets[0].backgroundColor);
                }
            }, 200);
        };
    </script>

</body>

</html>